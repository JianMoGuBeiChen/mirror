{"ast":null,"code":"// Global settings API that works across all browsers and devices\nclass GlobalSettingsAPI {\n  constructor() {\n    this.ws = null;\n    this.reconnectInterval = null;\n    this.isConnected = false;\n    this.pendingUpdates = new Map();\n    this.listeners = new Set();\n    this.localCache = {};\n    this.init();\n  }\n  init() {\n    this.loadFromServer();\n    this.connect();\n\n    // Sync with localStorage for compatibility\n    this.syncWithLocalStorage();\n  }\n  async loadFromServer() {\n    try {\n      // Try multiple server URLs\n      const urls = [`http://${window.location.hostname}:8889/settings`, `http://localhost:8889/settings`, `http://127.0.0.1:8889/settings`];\n      for (const url of urls) {\n        try {\n          console.log('Trying to load settings from:', url);\n          const response = await fetch(url);\n          if (response.ok) {\n            const settings = await response.json();\n            this.localCache = settings;\n            this.updateLocalStorage(settings);\n            this.notifyListeners();\n            console.log('Loaded global settings from server:', url);\n            return;\n          }\n        } catch (e) {\n          console.log('Failed to connect to:', url);\n        }\n      }\n      throw new Error('All server URLs failed');\n    } catch (e) {\n      console.log('Failed to load settings from server, using localStorage');\n      this.loadFromLocalStorage();\n    }\n  }\n  loadFromLocalStorage() {\n    const keys = Object.keys(localStorage);\n    const settings = {};\n    keys.forEach(key => {\n      try {\n        settings[key] = localStorage.getItem(key);\n      } catch (e) {\n        // ignore\n      }\n    });\n    this.localCache = settings;\n  }\n  updateLocalStorage(settings) {\n    // Don't clear all localStorage, just update the settings we care about\n    Object.entries(settings).forEach(([key, value]) => {\n      if (value !== null && value !== undefined) {\n        localStorage.setItem(key, value);\n      } else {\n        localStorage.removeItem(key);\n      }\n    });\n  }\n  syncWithLocalStorage() {\n    // Listen for direct localStorage changes and sync to server\n    window.addEventListener('storage', e => {\n      if (!e.key) return; // ignore clear events\n      console.log('Storage event:', e.key, e.newValue);\n      if (!this.isApplyingRemote) {\n        this.updateSetting(e.key, e.newValue);\n      }\n    });\n\n    // Override localStorage methods to capture direct calls\n    const originalSetItem = localStorage.setItem.bind(localStorage);\n    const originalRemoveItem = localStorage.removeItem.bind(localStorage);\n    localStorage.setItem = (key, value) => {\n      originalSetItem(key, value);\n      console.log('localStorage.setItem:', key, value, 'isApplyingRemote:', this.isApplyingRemote);\n      if (!this.isApplyingRemote) {\n        this.updateSetting(key, value);\n      }\n    };\n    localStorage.removeItem = key => {\n      originalRemoveItem(key);\n      console.log('localStorage.removeItem:', key, 'isApplyingRemote:', this.isApplyingRemote);\n      if (!this.isApplyingRemote) {\n        this.updateSetting(key, null);\n      }\n    };\n  }\n  connect() {\n    try {\n      const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n\n      // Try multiple WebSocket URLs\n      const urls = [`${protocol}://${window.location.hostname}:8889`, `${protocol}://localhost:8889`, `${protocol}://127.0.0.1:8889`];\n      let urlIndex = 0;\n      const tryConnect = () => {\n        if (urlIndex >= urls.length) {\n          console.log('All WebSocket URLs failed, retrying in 5s...');\n          this.reconnect();\n          return;\n        }\n        const url = urls[urlIndex];\n        console.log('Trying WebSocket connection to:', url);\n        this.ws = new WebSocket(url);\n        this.ws.onopen = () => {\n          console.log('Connected to global settings WebSocket:', url);\n          this.isConnected = true;\n          if (this.reconnectInterval) {\n            clearInterval(this.reconnectInterval);\n            this.reconnectInterval = null;\n          }\n          this.processPendingUpdates();\n        };\n        this.ws.onmessage = event => {\n          try {\n            const data = JSON.parse(event.data);\n            if (data.type === 'settings_update') {\n              console.log('Received settings update via WebSocket');\n\n              // Only update if settings actually changed\n              const currentSettingsStr = JSON.stringify(this.localCache);\n              const newSettingsStr = JSON.stringify(data.settings);\n              if (currentSettingsStr !== newSettingsStr) {\n                // CRITICAL: Set flag to prevent feedback loop\n                this.isApplyingRemote = true;\n                this.localCache = data.settings;\n                this.updateLocalStorage(data.settings);\n                this.notifyListeners();\n\n                // Clear flag after a brief delay\n                setTimeout(() => {\n                  this.isApplyingRemote = false;\n                }, 100);\n                console.log('Settings applied and UI updated');\n              }\n            }\n          } catch (e) {\n            console.error('Invalid WebSocket message:', e);\n          }\n        };\n        this.ws.onclose = () => {\n          console.log('WebSocket connection closed:', url);\n          this.isConnected = false;\n          this.reconnect();\n        };\n        this.ws.onerror = error => {\n          console.log('WebSocket error for', url, '- trying next...');\n          urlIndex++;\n          setTimeout(tryConnect, 100);\n        };\n      };\n      tryConnect();\n    } catch (error) {\n      console.log('Failed to connect to WebSocket server:', error);\n      this.reconnect();\n    }\n  }\n  reconnect() {\n    if (!this.reconnectInterval) {\n      this.reconnectInterval = setInterval(() => {\n        this.connect();\n      }, 5000);\n    }\n  }\n  async updateSetting(key, value) {\n    // Update local cache immediately\n    if (value === null) {\n      delete this.localCache[key];\n    } else {\n      this.localCache[key] = value;\n    }\n\n    // Try WebSocket first\n    if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {\n      try {\n        this.ws.send(JSON.stringify({\n          type: 'settings_change',\n          key: key,\n          newValue: value\n        }));\n        return;\n      } catch (e) {\n        console.log('WebSocket send failed, using HTTP');\n      }\n    }\n\n    // Fallback to HTTP\n    this.pendingUpdates.set(key, value);\n    this.processPendingUpdates();\n  }\n  async processPendingUpdates() {\n    if (this.pendingUpdates.size === 0 || this.isApplyingRemote) return;\n    try {\n      const updates = Object.fromEntries(this.pendingUpdates);\n      console.log('Processing pending updates:', updates);\n\n      // Try multiple server URLs for HTTP fallback\n      const urls = [`http://${window.location.hostname}:8889/settings`, `http://localhost:8889/settings`, `http://127.0.0.1:8889/settings`];\n      for (const url of urls) {\n        try {\n          const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(updates)\n          });\n          if (response.ok) {\n            this.pendingUpdates.clear();\n            console.log('Synced pending updates via HTTP:', url);\n            return;\n          }\n        } catch (e) {\n          console.log('HTTP sync failed for:', url);\n        }\n      }\n      throw new Error('All HTTP sync URLs failed');\n    } catch (e) {\n      console.log('Failed to sync pending updates:', e);\n    }\n  }\n  addListener(callback) {\n    this.listeners.add(callback);\n  }\n  removeListener(callback) {\n    this.listeners.delete(callback);\n  }\n  notifyListeners() {\n    this.listeners.forEach(callback => {\n      try {\n        callback(this.localCache);\n      } catch (e) {\n        console.error('Listener error:', e);\n      }\n    });\n  }\n  getSetting(key) {\n    return this.localCache[key] || localStorage.getItem(key);\n  }\n  getAllSettings() {\n    return {\n      ...this.localCache\n    };\n  }\n}\n\n// Export singleton\nexport const globalSettings = new GlobalSettingsAPI();\n\n// Compatibility layer - override localStorage for seamless integration\nwindow.addEventListener('load', () => {\n  // Make sure all components use the global settings\n  globalSettings.addListener(() => {\n    // Dispatch storage events for existing components\n    window.dispatchEvent(new Event('storage'));\n  });\n});","map":{"version":3,"names":["GlobalSettingsAPI","constructor","ws","reconnectInterval","isConnected","pendingUpdates","Map","listeners","Set","localCache","init","loadFromServer","connect","syncWithLocalStorage","urls","window","location","hostname","url","console","log","response","fetch","ok","settings","json","updateLocalStorage","notifyListeners","e","Error","loadFromLocalStorage","keys","Object","localStorage","forEach","key","getItem","entries","value","undefined","setItem","removeItem","addEventListener","newValue","isApplyingRemote","updateSetting","originalSetItem","bind","originalRemoveItem","protocol","urlIndex","tryConnect","length","reconnect","WebSocket","onopen","clearInterval","processPendingUpdates","onmessage","event","data","JSON","parse","type","currentSettingsStr","stringify","newSettingsStr","setTimeout","error","onclose","onerror","setInterval","readyState","OPEN","send","set","size","updates","fromEntries","method","headers","body","clear","addListener","callback","add","removeListener","delete","getSetting","getAllSettings","globalSettings","dispatchEvent","Event"],"sources":["C:/Users/shaku/Documents/React JS Apps/Reflect/src/utils/globalSettings.js"],"sourcesContent":["// Global settings API that works across all browsers and devices\r\nclass GlobalSettingsAPI {\r\n  constructor() {\r\n    this.ws = null;\r\n    this.reconnectInterval = null;\r\n    this.isConnected = false;\r\n    this.pendingUpdates = new Map();\r\n    this.listeners = new Set();\r\n    this.localCache = {};\r\n    this.init();\r\n  }\r\n\r\n  init() {\r\n    this.loadFromServer();\r\n    this.connect();\r\n    \r\n    // Sync with localStorage for compatibility\r\n    this.syncWithLocalStorage();\r\n  }\r\n\r\n  async loadFromServer() {\r\n    try {\r\n      // Try multiple server URLs\r\n      const urls = [\r\n        `http://${window.location.hostname}:8889/settings`,\r\n        `http://localhost:8889/settings`,\r\n        `http://127.0.0.1:8889/settings`\r\n      ];\r\n      \r\n      for (const url of urls) {\r\n        try {\r\n          console.log('Trying to load settings from:', url);\r\n          const response = await fetch(url);\r\n          if (response.ok) {\r\n            const settings = await response.json();\r\n            this.localCache = settings;\r\n            this.updateLocalStorage(settings);\r\n            this.notifyListeners();\r\n            console.log('Loaded global settings from server:', url);\r\n            return;\r\n          }\r\n        } catch (e) {\r\n          console.log('Failed to connect to:', url);\r\n        }\r\n      }\r\n      throw new Error('All server URLs failed');\r\n    } catch (e) {\r\n      console.log('Failed to load settings from server, using localStorage');\r\n      this.loadFromLocalStorage();\r\n    }\r\n  }\r\n\r\n  loadFromLocalStorage() {\r\n    const keys = Object.keys(localStorage);\r\n    const settings = {};\r\n    keys.forEach(key => {\r\n      try {\r\n        settings[key] = localStorage.getItem(key);\r\n      } catch (e) {\r\n        // ignore\r\n      }\r\n    });\r\n    this.localCache = settings;\r\n  }\r\n\r\n  updateLocalStorage(settings) {\r\n    // Don't clear all localStorage, just update the settings we care about\r\n    Object.entries(settings).forEach(([key, value]) => {\r\n      if (value !== null && value !== undefined) {\r\n        localStorage.setItem(key, value);\r\n      } else {\r\n        localStorage.removeItem(key);\r\n      }\r\n    });\r\n  }\r\n\r\n  syncWithLocalStorage() {\r\n    // Listen for direct localStorage changes and sync to server\r\n    window.addEventListener('storage', (e) => {\r\n      if (!e.key) return; // ignore clear events\r\n      console.log('Storage event:', e.key, e.newValue);\r\n      if (!this.isApplyingRemote) {\r\n        this.updateSetting(e.key, e.newValue);\r\n      }\r\n    });\r\n\r\n    // Override localStorage methods to capture direct calls\r\n    const originalSetItem = localStorage.setItem.bind(localStorage);\r\n    const originalRemoveItem = localStorage.removeItem.bind(localStorage);\r\n\r\n    localStorage.setItem = (key, value) => {\r\n      originalSetItem(key, value);\r\n      console.log('localStorage.setItem:', key, value, 'isApplyingRemote:', this.isApplyingRemote);\r\n      if (!this.isApplyingRemote) {\r\n        this.updateSetting(key, value);\r\n      }\r\n    };\r\n\r\n    localStorage.removeItem = (key) => {\r\n      originalRemoveItem(key);\r\n      console.log('localStorage.removeItem:', key, 'isApplyingRemote:', this.isApplyingRemote);\r\n      if (!this.isApplyingRemote) {\r\n        this.updateSetting(key, null);\r\n      }\r\n    };\r\n  }\r\n\r\n  connect() {\r\n    try {\r\n      const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\r\n      \r\n      // Try multiple WebSocket URLs\r\n      const urls = [\r\n        `${protocol}://${window.location.hostname}:8889`,\r\n        `${protocol}://localhost:8889`,\r\n        `${protocol}://127.0.0.1:8889`\r\n      ];\r\n      \r\n      let urlIndex = 0;\r\n      \r\n      const tryConnect = () => {\r\n        if (urlIndex >= urls.length) {\r\n          console.log('All WebSocket URLs failed, retrying in 5s...');\r\n          this.reconnect();\r\n          return;\r\n        }\r\n        \r\n        const url = urls[urlIndex];\r\n        console.log('Trying WebSocket connection to:', url);\r\n        \r\n        this.ws = new WebSocket(url);\r\n        \r\n        this.ws.onopen = () => {\r\n          console.log('Connected to global settings WebSocket:', url);\r\n          this.isConnected = true;\r\n          if (this.reconnectInterval) {\r\n            clearInterval(this.reconnectInterval);\r\n            this.reconnectInterval = null;\r\n          }\r\n          this.processPendingUpdates();\r\n        };\r\n\r\n        this.ws.onmessage = (event) => {\r\n          try {\r\n            const data = JSON.parse(event.data);\r\n            if (data.type === 'settings_update') {\r\n              console.log('Received settings update via WebSocket');\r\n              \r\n              // Only update if settings actually changed\r\n              const currentSettingsStr = JSON.stringify(this.localCache);\r\n              const newSettingsStr = JSON.stringify(data.settings);\r\n              \r\n              if (currentSettingsStr !== newSettingsStr) {\r\n                // CRITICAL: Set flag to prevent feedback loop\r\n                this.isApplyingRemote = true;\r\n                \r\n                this.localCache = data.settings;\r\n                this.updateLocalStorage(data.settings);\r\n                this.notifyListeners();\r\n                \r\n                // Clear flag after a brief delay\r\n                setTimeout(() => {\r\n                  this.isApplyingRemote = false;\r\n                }, 100);\r\n                \r\n                console.log('Settings applied and UI updated');\r\n              }\r\n            }\r\n          } catch (e) {\r\n            console.error('Invalid WebSocket message:', e);\r\n          }\r\n        };\r\n\r\n        this.ws.onclose = () => {\r\n          console.log('WebSocket connection closed:', url);\r\n          this.isConnected = false;\r\n          this.reconnect();\r\n        };\r\n\r\n        this.ws.onerror = (error) => {\r\n          console.log('WebSocket error for', url, '- trying next...');\r\n          urlIndex++;\r\n          setTimeout(tryConnect, 100);\r\n        };\r\n      };\r\n\r\n      tryConnect();\r\n    } catch (error) {\r\n      console.log('Failed to connect to WebSocket server:', error);\r\n      this.reconnect();\r\n    }\r\n  }\r\n\r\n  reconnect() {\r\n    if (!this.reconnectInterval) {\r\n      this.reconnectInterval = setInterval(() => {\r\n        this.connect();\r\n      }, 5000);\r\n    }\r\n  }\r\n\r\n  async updateSetting(key, value) {\r\n    // Update local cache immediately\r\n    if (value === null) {\r\n      delete this.localCache[key];\r\n    } else {\r\n      this.localCache[key] = value;\r\n    }\r\n\r\n    // Try WebSocket first\r\n    if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {\r\n      try {\r\n        this.ws.send(JSON.stringify({\r\n          type: 'settings_change',\r\n          key: key,\r\n          newValue: value\r\n        }));\r\n        return;\r\n      } catch (e) {\r\n        console.log('WebSocket send failed, using HTTP');\r\n      }\r\n    }\r\n\r\n    // Fallback to HTTP\r\n    this.pendingUpdates.set(key, value);\r\n    this.processPendingUpdates();\r\n  }\r\n\r\n  async processPendingUpdates() {\r\n    if (this.pendingUpdates.size === 0 || this.isApplyingRemote) return;\r\n\r\n    try {\r\n      const updates = Object.fromEntries(this.pendingUpdates);\r\n      console.log('Processing pending updates:', updates);\r\n      \r\n      // Try multiple server URLs for HTTP fallback\r\n      const urls = [\r\n        `http://${window.location.hostname}:8889/settings`,\r\n        `http://localhost:8889/settings`,\r\n        `http://127.0.0.1:8889/settings`\r\n      ];\r\n      \r\n      for (const url of urls) {\r\n        try {\r\n          const response = await fetch(url, {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify(updates)\r\n          });\r\n\r\n          if (response.ok) {\r\n            this.pendingUpdates.clear();\r\n            console.log('Synced pending updates via HTTP:', url);\r\n            return;\r\n          }\r\n        } catch (e) {\r\n          console.log('HTTP sync failed for:', url);\r\n        }\r\n      }\r\n      throw new Error('All HTTP sync URLs failed');\r\n    } catch (e) {\r\n      console.log('Failed to sync pending updates:', e);\r\n    }\r\n  }\r\n\r\n  addListener(callback) {\r\n    this.listeners.add(callback);\r\n  }\r\n\r\n  removeListener(callback) {\r\n    this.listeners.delete(callback);\r\n  }\r\n\r\n  notifyListeners() {\r\n    this.listeners.forEach(callback => {\r\n      try {\r\n        callback(this.localCache);\r\n      } catch (e) {\r\n        console.error('Listener error:', e);\r\n      }\r\n    });\r\n  }\r\n\r\n  getSetting(key) {\r\n    return this.localCache[key] || localStorage.getItem(key);\r\n  }\r\n\r\n  getAllSettings() {\r\n    return { ...this.localCache };\r\n  }\r\n}\r\n\r\n// Export singleton\r\nexport const globalSettings = new GlobalSettingsAPI();\r\n\r\n// Compatibility layer - override localStorage for seamless integration\r\nwindow.addEventListener('load', () => {\r\n  // Make sure all components use the global settings\r\n  globalSettings.addListener(() => {\r\n    // Dispatch storage events for existing components\r\n    window.dispatchEvent(new Event('storage'));\r\n  });\r\n});\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}